### 注解



> @Component  泛指组件，不好归类时使用
>
> @Controller  标注控制层组件
>
> @Service 标注业务逻辑层组件
>
> @Repository 标注数据访问层组件，可以标注在任何类上
>
>@Configuration 配置类模式注解

都是普通pojo实例化到spring容器中，

源码上都是使用的 @Component  



#### @ConfigrationProperties、@Value

通过注解获取放在application.properties等配置文件中的配置信息

>    `@ConfigrationProperties`的基本用法,为每个捕获的外部属性提供一个带字段的类

*   前缀定义了哪些外部属性将绑定在类的字段上

*   简单的用一个值初始化一个字段定一个默认值

*   类的字段必须有公共setter方法

*   根据 Spring Boot 宽松的绑定规则，类的属性名称必须与外部属性的名称匹配

    ``` properties
    #Spring的宽松绑定规则
    #以下属性都会被绑定到hostName上
    spring.redis.hostName=127.0.0.1
    spring.redis.hostname=127.0.0.1
    spring.redis.host_name=127.0.0.1
    spring.redis.host_Name=127.0.0.1
    ```

>   激活`@ConfigrationProperties`

​	需要将配置类bean加上`@Component`注解注入到应用程序上下文



>   实例

```java
@Component
@ConfigurationProperties(prefix = "spring.redis", ignoreUnknownFields = false) //读取前缀为spring.redis的配置， ignoreUnknownFields 前缀不符合是抛出异常
@PropertySource("classpath:redis.properties")
public class DefaultRedisProperty extends RedisProperty{
}

@Data
public class RedisProperty {

    private String host = "localhost";
    private Integer port = 6379;
    private Integer database = 0;

    /**
     * ms
     */
    private Integer timeout = 100;

    /**
     * 连接池
     */
    private Boolean testOnBorrow = true;
    private Boolean testOnReturn = true;
    private Integer maxActive = 8;
    private Integer maxIdle = 8;
    private Integer minIdle = 0;
    private Integer maxWait = -1;
    private Integer maxTotal = 8;
}
```

prefix : 配置文件中需要获取属性的前缀

ignoreUnknownFields : 忽略未知的字段(相同前缀缺无字段对应的配置属性)

ignoreInvalidFields : 是否忽略验证失败的字段，类型不一致

PropertySource("classpath:redis.properties") : 获取指定配置文件中的配置

对于List或者set类型，在配置文件中以数组的形式书写

```properties
test.id=1
test.habit[0]=dandan
test.habit[1]=dandan
```



`@value`

*   常量注入 **@value("")**

*   bean属性、系统属性、表达式注入 **@Value("#{}")**

*   配置文件属性注入 **@Value{"${}"}**

    ```java
    @Component
    @PropertySource("classpath:test.properties")
    @Data
    public class TestValueProperty {
    
        @Value("2")
        private Integer id;
    
        @Value("#{defaultRedisProperty.host}")
        private String hostName;
    
        @Value("${test.birth}")
        private String birth;
    }
    ```
`@RegisterMapper `

  可以避免 mappers 参数配置，通用 Mapper 检测到该接口被继承时，会自动注册。
  
  `@provide` 用于mapper集成扩展通用接口
  
  主要分为四种：@InsertProvider、@DeleteProvider、@UpdateProvider和@SelectProvider，分别对应着sql中的增删改查四种操作。
  
  四种注解的使用方式相同，故以@UpdateProvider介绍：
  
    /**
     * 通过主键更新
     * 注意：domain中为null的字段也会被更新到数据库。
     * 正确使用方式：先根据id从数据库查出domain然后修改需要更新的值，然后使用该方法update
     *
     * @param domain 领域对象
     * @return affected rows, 0 or 1
     */
    @UpdateProvider(type = CommonProvider.class, method = "dynamicSQL")
    int updateById(T domain);
    -------------------------------------------------------------------------------------------
   其中的两个参数，XXX.class代表指定的一个类，用户自定义；method代表这个类中的一个函数，用来返回sql语句，这个函数返回值必须是String类型函数，返回的就是一个sql字符串。//TODO argue
   
   CommonProvider.class：
   
         /**
         * 通过主键更新
         */
        public String updateById(MappedStatement ms) {
            Class<?> entityClass = getEntityClass(ms);
            StringBuilder sql = new StringBuilder();
            sql.append(SqlHelper.updateTable(entityClass, tableName(entityClass)));
            sql.append(updateSetColumns(entityClass, null, false, false));
            sql.append(SqlHelper.wherePKColumns(entityClass, true));
            return sql.toString();
        }
    
   CommonProvider extends MapperTemplate
   
       public String dynamicSQL(Object record) {
           return "dynamicSQL";
       }

  
  `@Autowired`
  
  @Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。在使用@Autowired之前，我们对一个bean配置起属性时，是这样的
 ` <property name="属性名" value=" 属性值"/>    `
  通过这种方式来，配置比较繁琐，而且代码比较多。在Spring 2.5 引入了 @Autowired 注释
  
  　启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource(是CommonAnnotationBeanPostProcessor后置处理器处理的)或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性
  
   `<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/> `  　　
  
   注意事项：
  
  　　在使用`@Autowired`时，首先在容器中查询对应类型的bean
  
  　　　　如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据
  
  　　　　如果查询的结果不止一个，那么`@Autowired`会根据名称来查找。
  
  　　　　如果查询的结果为空，那么会抛出异常。解决方法时，使用required=false