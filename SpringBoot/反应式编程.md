#### 反应式编程

反应式编程 (reactive programming) 是一种基于数据流 (data stream) 和 变化传递 (propagation of change) 的声明式 (declarative) 的编程范式

##### 反应式编程特点

*   事件驱动

    在一个 **事件驱动** 的应用程序中，组件之间的交互是通过松耦合的 **生产者** `(production)`和 **消费者** `(consumption)` 来实现的。这些事件是以 **异步** 和 **非阻塞** 的方式发送和接收的。

    **事件驱动** 的系统依靠 **推模式** 而不是 **拉模式** 或 **投票表决**，即 **生产者** 是在有消息时才推送数据给 **消费者**，而不是通过一种浪费资源方式：让 **消费者** 不断地 **轮询** 或 **等待数据**。

*   实时响应

    程序发起执行以后，应该 **快速** 返回存储 **结果的上下文**，把具体执行交给 **后台线程**。待处理完成以后，异步地将 **真实返回值** 封装在此 **上下文** 中，而不是 **阻塞** 程序的执行。实时响应是通过 **异步** 编程实现的，例如：发起调用后，快速返回类似 `java8` 中 `CompletableFuture` 对象。

*   弹性机制

    事件驱动的 **松散耦合** 提供了组件在失败下，可以抓获 **完全隔离** 的上下文场景，作为 **消息封装**，发送到下游组件。在具体编程时可以 **检查错误** ，比如：是否接收到，接收的命令是否可执行等，并决定如何应对。

###### 负压

​		在基本的消息推送模式中，当消息发布者产生数据的速度过快时，会使得消息订阅者的处理速度无法跟上产生的速度，从而给订阅者造成很大的压力。当压力过大时，有可能造成订阅者本身的奔溃，所产生的级联效应甚至可能造成整个系统的瘫痪。负压的作用在于提供一种从订阅者到生产者的反馈渠道。订阅者可以通过 request()方法来声明其一次所能处理的消息数量，而生产者就只会产生相应数量的消息，直到下一次 request()方法调用。这实际上变成了推拉结合的模式。

反应式流的规范可以总结为四个接口：**Publisher(被订阅者)**、**Subscriber(订阅者)**、**Subscription**、**processor**

#### Publisher

**Publisher** 负责生成数据，并将数据发送给 **Subscription** (每个 **Subscriber** 对应一个 **Subscription** )

**Publisher** 声明了一个方法 subscriber() , **Subscriber** 可以通过该方法向 **Publisher** 发起订阅

