#### Go 基本语法

#### 基本数据类型

>   bool 类型

布尔值不会隐式转换到int ，反之亦然

封装函数

```go
func btoi(b bool) int {
	if b {
		return 1
	}
	return 0
}

func itob (i int ) bool {
	return i != 0
}
```



>   字符串

一个字符串是一个不可改变的字节序列。可以包含任何数据，通常包含可读的文本

字符串通常解释为采用UTF8编码的Unicode码点(rune) 序列

第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个 字节



原生字符串面值的形式是 \` `，使用反引号代替双引号，在原生的字符串面值中，没有转义，全部的内容都是字面的意思，包含退格和换行

rune类型

rune类型用来区分字符值与整数值，是int32 的别名



>   常量

常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型： boolean、string或数字

```go
const (
	name = "dandan"
	a = iota
	b
	c
	d
)
```

itoa 常量生成器

常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不 用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行， iota将会被置为0，然后在每一个有常量声明的行加一。



#### 复合数据类型

##### 数组

数组的长度需要在编译阶段确定

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。 因为数组的长度是固定的，所以很少使用

数组的索引可以自己制定

```go
var a [3]int
a := [3]int{1,2}
b := [...]{1,2,3}  //根据初始值的个数定义长度
```



当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数 参数变量接收的是一个复制的副本，并不是原始调用的变量。因为函数参数传递的机制导致 传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并 不能直接修改调用时原始的数组变量

##### slice

```go
s1 := []int{1,2,3} ////在内存中构建一个包括有3个元素的数组，然后将这个数组的引用赋值给s这个Slice
a := [5]{1,2,3,4,5}  //a 是数组
sl := s[i:j]  //通过截取数组进行初始化
sc := make([]int, 10, 20)  //make函数初始化 len=10， cap=20
```

**在追加元素时，如果容量cap不足时，cap一般变为原来的2倍来实现扩容**

len为切片的长度指，cap为切片底层数组的容量

Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作 []T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已

一个slice是一个轻量级的数据结构，提供了访问数组子序 列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象

一个slice由三个部分 构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的 是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不 能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分 别返回slice的长度和容量。

```go
s := [...]int{1,2,3,4,5}
s[i:j] //引用s开始的第i个到第j-1个元素的子序列
```

![](..\Img\GoSlice.PNG)





##### map

```go
maps := make(map[int]string) //通过内置的make函数初始化map
maps := map[string]int{"name": 1, "age": "2"}	 

//内置的delete删除元素
delete(maps, "name")
```

Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践 中，遍历的顺序是随机的，每一次遍历的顺序都不相同

```go

```



##### 结构体



>   new 函数

new函数可以创建变量，表达式 **new(T)** 将创建一个T类型的匿名变量，初始化为T类型的零值，返回变量地址**(*T)**



