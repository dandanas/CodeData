### MySQL 

#### MySql的基本架构

Mysql可以分为Server层和存储引擎两部分

![MySQL逻辑架构图](..\Img\Mysql逻辑架构图.png)

Server层包括连接器、查询缓存、分析器、优化器、执行器等，包含MySQL的大部分核心服务，以及所有的内置函数，所有跨引擎的功能都在这一层，如存储过程、触发器、视图。

存储引擎负责数据的存储与提取。存储引擎的架构模式为插件式，支持InnoDB、MyISAM、Memory 等多个存储引擎。（默认存储引擎为InnoDB）

###### 连接器

*   客户端与数据库建立连接

*   show processlist 显示MySQL数据库的连接情况

    >   ​	show processlist

*   长连接 短连接
    *   长连接：连接成功后，客户端持续请求，则一直使用同一个链接
    *   短连接：每次执行完几次很少的查询就断开连接、下次查询在重新建立连接
*   建立连接比较耗费性能,但是长连接时间长了又耗费内存
    *   定期断开连接，在使用了一个占用大内存的连接后，断开连接，重新连接、
    *   每次使用一个较大连接后，执行mysql_reset_connection 重新初始化资源
*   通过设置 **wait_timeout** 进行闲置时间控制

###### 查询缓存

MySQL在拿到查询请求后，会先到查询缓存查看，之前是不是执行过这条语句，之前执行的结果可能会以key-value对的形式直接缓存在内存中。key是查询语句，value是查询结果。如果在查询缓存中直接找到key，哪个value则会呗直接返回给客户端。

**大多数情况下不建议使用查询缓存**

查询缓存失效的非常频繁，只要对一张表进行更新，那么这张表上所有的查询缓存都会被清空。除非一张静态表，长时间才更新一次。

###### 分析器

*   格式化SQL
*   校验SQL正确性

先做词法分析格式化SQL

做完识别之后再做“语法分析”，根据词法分析的结果，语法分析器会根据语法规则，判断输入的SQL语句是否满足MySQL语法，校验SQL正确性。

###### 优化器

*   判断是否使用索引以及使用哪个索引
*   判断如何关联表

在一个语句有多表关联的时候，决定各个表的连接顺序

###### 执行器

*   判断用户是否有对标的执行权限，没有则报错返回
*   根据条件从数据库获取数据返回
    *   没有缩影，查询全量表
    *   有索引，从满足条件的第一条数据开始查询，直到数据不满足为止

执行流程：

1.调用InnoDB引擎接口取这个表的第一行，判断是否满足条件，不是则跳过，是则将此行存储在结果集中

2.调用引擎接口取“下一行”，重复逻辑判断，直到取到表的最后一行(全量查表)

3.执行器将上述遍历过程中所有满足条件的行组成结果集返回给客户端

>   对于有索引的表，执行逻辑差不多，只不过第一次调用的是 "取满足条件的第一行" 接口

在数据库的慢查询日志中会有 rows_examined 的字段，表示这个语句执行过程中扫描了多少行，这个值是在执行器每次调用引擎获取数据行的时候累加的。

在某些情况下，执行器调用一次，在引擎内部扫描了多行，所以**引擎扫描行数与rows_examined 并不是完全相同的**

#### MySQL 日志模块

更新语句也许要经过查询语句的那一套流程

当表上有更新时，与这张表有关的查询缓存都会失效

###### MySQL 的日志类型

![](..\Img\MySQL日志类型.png)

>   **redo log**

​	 redo log 在数据库重启恢复的时候使用，因为是物理日志，回复的速度远快于逻辑日志

>   **bin log**

​	bin log 属于典型的逻辑日志



#### 事务

##### 事务定义

*   Transaction
*   事务是一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(银行账户转账)
*   一个完整的业务需要批量的DML(insert、update、 delete)语句共同完成
*   事务只与DML 语句有关

##### 事务的特性(ACID)

*   Atomicity 原子性: 事务的操作要么全部成功，要么全部失败回滚。
*   Consistency 一致性: 事务必须使数据库从一个一致性状态变换到另一个一致性状态(语义上)
*   Isolation 隔离性: 对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始前就结束了，要么在T1结束后才开始，每个事务感觉不到其他的事务在并发执行
*   Durability 持久性: 事务一旦提交，那么对数据库的数据改变就是永久性的

#####  事务的隔离性引发的问题

*   **脏读（读取未提交数据）**

    在一个事务处理过程中读取了另一个事务未提交的数据（**回滚前的脏数据**）

    当事务T1正在修改某个数据，而在这个事务中的修改都还未提交，这时一个并发的事务T2来访问该数据，如果事务T1出现问题不提交则会全部回滚，那么事务T1读到的就是脏数据

    | 时间顺序 |      事务T1 (转账事务)       |             事务T2 (取款事务)              |
    | :------: | :--------------------------: | :----------------------------------------: |
    |    1     |                              |                 开始事务T2                 |
    |    2     |          开启事务T1          |                                            |
    |    3     |                              |               查询余额5000元               |
    |    4     |                              |       取款2000元，余额被修改为3000元       |
    |    5     |  查询余额3000元 (**脏读**)   |                                            |
    |    6     |                              | 取款发生未知错误，事务回滚，余额变为5000元 |
    |    7     | 转入2000元，余额被改为4000元 |                                            |
    |    8     |           提交事务           |                                            |
    |          |                              |       按正常逻辑，此时余额应为7000元       |



*   **不可重复读**（**前后多次读取，数据不一致**）

    T1事务先读取了一条数据，在执行逻辑的时候，事务T2改变了这条数据，T1再次读这个数据时，发现数据不匹配，T1事务形成了不可重复读

    | 执行顺序 |                        事务T1                        |     事务T2      |
    | :------: | :--------------------------------------------------: | :-------------: |
    |    1     |                       开始事务                       |                 |
    |    2     |                第一次查询A年龄为20岁                 |                 |
    |    3     |                                                      |    开始事务     |
    |    4     |                       逻辑操作                       |                 |
    |    5     |                                                      | 修改A年龄为30岁 |
    |    6     |                                                      |    提交事务     |
    |    7     | 第二次查询，A年龄为30岁 (**前后查询到的数据不一致**) |                 |



*   **幻读** （**前后多次读取，数据总量不一致**）

    事务T1根据条件索引到M条数据，然后事务T2改变了这M条之外的N条数据（修改使其符合T1搜索条件）或者添加了符合事务T1搜索条件的数据，导致事务A再次查询发现有M+N条数据，产生幻读

    | 执行顺序 | 事务T1                           | 事务T2                                |
    | -------- | -------------------------------- | ------------------------------------- |
    | 1        | 开启事务                         |                                       |
    | 2        | 第一次查询，查询到数据数量为10   |                                       |
    | 3        |                                  | 开启事务                              |
    | 4        | 其他操作                         |                                       |
    | 5        |                                  | 新增10条数据/修改数据满足T1的查询条件 |
    | 6        |                                  | 提交事务                              |
    | 7        | 第二次查询，查询到的数据数量为20 |                                       |

幻读与不可重复读的区别在于，不可重复读主要是 update , 而幻读会有insert操作

##### MySQL的事务隔离级别

*   **读未提交 **(**Read Uncommitted**)

    一个事务还未提交，他的变更能被别的事务看到

*   **读已提交** (**Read Committed**)

    一个事务提交后，它做的变更才能被其他事物看到

*   **可重复读** (**Repeatable Read**)

    事务在执行过程中看到的数据，总是与事务启动时看到的数据是一致的

    在可充重复读的隔离级别下，未提交的变更对其他事务是不可见的

    **Repeatable Read** 是MySQL的默认事务隔离级别

*   **串行化** (**Serializable**)

     通过强制事务串行执行，避免幻读。**Serializable**会在读取的每一条数据上都加锁，可能会导致大量的超时和锁争用。
    
    只有在非常需要确保数据一致性且接收没有并发的情况下才考虑使用

```sql
show variables like 'transaction_isolation' ;
select @@transaction_isolation;   查看当前的隔离级别

set session transaction isolation level READ COMMITTED ; 修改当前隔离级别
```

MySQL的四种隔离级别可能会出现的问题

|       隔离级别       | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| :------------------: | :--: | :--------: | :--: | :----: |
| **Read Uncommitted** |  √   |     √      |  √   |   ×    |
|  **Read Committed**  |  ×   |     √      |  √   |   ×    |
|  **Read Committed**  |  ×   |     ×      |  √   |   ×    |
|   **Serializable**   |  ×   |     ×      |  ×   |   √    |

##### 事务隔离的实现



##### 死锁

两个或多个事务在同一资源上的相互占用，并请求锁定对方占用的资源，从而导致恶性循环。多个事务试图以不同的顺序锁定资源时，可能会产生死锁

```sql
start Transaction
update StockPrice set close = 33.3 where stock_id = 4 and data = '2020-02-10'
update StockPrice set close = 12.2 where stock_id = 3 and data = '2020-02-11'
commint;

start Transaction
update StockPrice set close = 43.1 where stock_id = 3 and data = '2020-02-11'
update StockPrice set close = 17.2 where stock_id = 4 and data = '2020-02-10'
commint;
```

两个事务都执行了第一条语句，锁定了该行，每个事务都等待对方释放锁，同时又持有对方需要的锁，形成死锁。

InnoDB 处理方式，将持有最少行级排它锁的事务进行回滚。



#### 多版本并发控制

基于提升性能的考虑，一般采用多版本并发控制(**MVCC**)

**MVCC**的实现是通过保存数据在某个时间点的快照实现的。不管运行多长时间，每个事务看到的数据都是一致的

根据事务开始时间的不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的

不同引擎的**MVCC**实现是不同的，典型的有**乐观(optimistic)并发控制**和**悲观(pessimistic)并发控制**



##### InnoDb的MVCC实现

通过在每行记录后面保存两个隐藏的列实现，一个保存行的创建时间，一个保存行的过期时间(删除时间)。存储的并不是实际值而是系统版本号。每开启一个事务，系统版本号都会递增。事务开启时刻的版本号会作为事务的版本号，用来和查询到的每行记录版本号进行比较

>   REPEATABLE READ 几倍下的实现

​	SELECT 

​		InnoDB会根据下面两个条件检查每行记录

​			a. InnoDB只查找版本早于当前事务版本的数据行( 行的系统版本号小于等于事务的系统版本号)， 这样可以			确保事务读取的行，要么是在事务开始的时候已经存在，要么是自身插入或修改过的

​			b.行的删除版本要么未定义，要么大于当前事务版本号，确保事务读取到的行，在事物开始的时候未被删除

​	INSERT

​		InnoDB为新插入的每一行保存当前系统版本号作为版本号

​	DELETE

​		为删除的每一行保存当前系统版本号作为删除标识

​	UPDATE

​		InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来行作为删除		标识

**MVCC**只在 **REPEATABLE READ**和**READ COMMINTED**两个隔离级别下工作，其他两个级别与**MVCC **不兼容

**READ UNCOMMITED**总是读取最新行，而不是符合当前事务版本的数据行

**SERIALIZABLE**则会对所有读取的行加锁