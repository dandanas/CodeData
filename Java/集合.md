## 集合
Java 集合框架主要包括两种类型的容器，一种是Collection，存储一个元素集合，另一种是Map，存储键/值对映射。  
Collection 接口又有 3 种子类型，List（元素是有序的且可重复）、Set（元素是无序的且不可重复） 和 Queue（封装了数据结构中的队列）  
## 1.List
容器里面存的是对象的引用地址，调用`remove`方法的时候是在容器中移除的引用地址，而不是删除了对象`clear`同理
有序，可重复（e1 .equals(e2))
 
常用的实现类
### ArrayList
#### 特点
>查询效率高  

Array是用数组实现的，数组只需对 [基地址+元素大小*k] 就能找到第k+1个元素的地址，对其取地址就能获得该元素。
链表要获得第k个元素，这样就要从第一个元素找起，多了多步寻址操作，当数据量大且其它操作较少时，这就有差距了。
>增删效率低

因为数组是一个有序列表,数组是在连续的位置上面储存对象的应用。当删除某一个元素的时候在他后面的元素的索引都会左移，增加元素同理
链表可以将待删除的节点的前继节点next指针直接指向待删除元素的后续节点即可

>线程相关
##### 解决方案对比
> Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降关键源码如下：
```java
public class safe{
 public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }

public synchronized void removeElementAt(int index) {
        modCount++;
        if (index >= elementCount) {
            throw new ArrayIndexOutOfBoundsException(index + " >= " +
                                                     elementCount);
        }
        else if (index < 0) {
            throw new ArrayIndexOutOfBoundsException(index);
        }
        int j = elementCount - index - 1;
        if (j > 0) {
            System.arraycopy(elementData, index + 1, elementData, index, j);
        }
        elementCount--;
        elementData[elementCount] = null; /* to let gc do its work */
    }

 public synchronized Iterator<E> iterator() {
        return new Itr();
    }
}
```

> CopyOnWriteArrayList 

只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况.  
写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种优化策略。其核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。
>Collections.synchronizedList(List list) 

转换包装后的list可以实现add，remove，get等操作的线程安全性，但是对于迭代操作，Collections.synchronizedList并没有提供相关机制，所以迭代时需要对包装后的list（Must be manually synched by user）进行手动加锁

```java

synchronized (safeList) {
    while (iterator.hasNext()) {
        String next = iterator.next();
        System.out.println(next);
    }

```
synchronizedList实现线程安全的方法就是对自己暴力加锁，在获取安全的list后遍历时，外层要用synchronized同步是因为list.iterator()在读取过程中，不会本来hasNext()有的，但在调用i.next()的时候，另外一个线程把它删了，这个synchronized块是为了保障这三行代码在多个线程里同时执行的并发问题。
至于synchronizedList的内部锁，是在并发执行add/remove的时候，不要把多个线程的东西加到list内部实现的同一个位置上去，导致数据丢失或者脏数据等问题，这是为了保证这个List在执行add/remove时不会存在并发问题。                                                                   

### 线程不安全的解决方案 
```java
package testList;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.CopyOnWriteArrayList;

public class TestListSafe {
   // ArrayList    
   //会导致add内容为null,迭代时并发修改list内容抛ConcurrentModificationException异常
   // protected static ArrayList<Object> arrayList = new ArrayList<Object>();

    // 解决措施1：使用Vector集合
   // protected static Vector<Object> arrayListSafe1 = new Vector<Object>();

    // 解决措施2：加上Collections.synchronizedList，它会自动将我们的list方法进行改变，最后返回给我们一个加锁了List
    //static List<Object> arrayListSafe2 = Collections.synchronizedList(new ArrayList<Object>());
    //解决措施3：使用CopyOnWriteArrayList
    static List<Object>  arrayListSafe3 = new CopyOnWriteArrayList();


    public static void main(String[] args) {
        Thread[] threads = new Thread[500];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new ArrayListThread();
            threads[i].start();
        }

        for (int i = 0; i < threads.length; i++) {
            try {
                threads[i].join();// 等待该线程终止    
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 输出list中的对象元素    
        for (int i = 0; i < threads.length; i++) {
            System.out.println(arrayListSafe3.get(i));
        }
    }
}

/**
 * 线程类，执行arrayList的add()增加方法  
 *
 */
class ArrayListThread extends Thread {

    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 增加元素    
        TestListSafe.arrayListSafe3.add(Thread.currentThread().getName());
    }

}
```
### LinkedList：链表
LinkedList底层的数据结构是基于双向循环链表的，且头结点中不存放数据,查询效率低，增删效率高，线程不安全
```java
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
{}
```
LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。  
AbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些函数。  
LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。  
LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆（浅克隆）。  
LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。
#### 线程不安全的解决方案
>方法一:List<String> list = Collections.synchronizedList(new LinkedList<String>());

>方法二:将LinkedList全部换成ConcurrentLinkedQueue
## 2.Set
### HashSet
无序不可重复，没有索引，如果要查找只能去遍历，且只能放一个null元素

如何来保证元素唯一性? 依赖两个方法：hashCode()和equals()，HashSet是采用Hash算法实现的，底层实际上是用HashMap实现的，调用add方法的时候，如下，其实是存放的map的key，而key是不能重复的
```java
  public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }

```
### LinkedHashSet
继承自HashSet，唯一的区别是LinkedHashSet内部使用的是LinkHashMap。这样做的意义或者好处就是LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。  
底层数据结构是链表和哈希表。(FIFO插入有序,唯一)  
1.由链表保证元素有序  
2.由哈希表保证元素唯一
### TreeSet
底层实际上是TreeMap,数据结构是红黑树。(唯一，有序) ，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序 

## 3.Map
Hashtable:线程安全，不允许key和value为空，效率低  
HashMap ：线程不安全，允许key和value为空，效率高 ，结构是数组+链表，JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。
其中Node[] table 就是HashMap核心的数组结构，也称为"位桶数组",源码如下：

```java
 static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

       //以下代码省略
    }
```

#### 一个Node对象存储了：
1.key 键对象 value 值对象  
2.next 下一个节点  
3.hash 键对象的hash值  
所以Node对象是一个单向链表结构，然后把链表存储在一个数组里面

### HashMap存储键值对的过程
1.先调用key对象的hashCode方法，获得hashCode
 
2.根据hashCode计算hash值，要求在[0,数组长度-1]之间

3.存储之后生成一个链表， 根据hash值，将Node对象存储到数组索引位置
  jdk8中，当链表的长度大于8的时候链表就转化为红黑树，这样大大提高了转化效率  
#### HashMap取数据的过程
1.先调用key对象的hashCode方法，获得hashCode  
2.根据hashCode计算hash值，要求在[0,数组长度-1]之间  
3.通过equals方法依次 比较，然后将对应的value对象返回回去  

Java中规定，两个内容相同equals为true的对象必须有相同的hashCode,如果不同，则发生了悖论

#### map遍历
```java
public class MapIterator {

    @Test
    public void test() {
        Map<String, String> map = new HashMap<String, String>();
        map.put("熊大", "棕色");
        map.put("熊二", "黄色");
        for (Map.Entry<String, String> entry : map.entrySet()) {
            String mapKey = entry.getKey();
            String mapValue = entry.getValue();
            System.out.println(mapKey + ":" + mapValue);
        }
    }

    /**
     * 只需要key 或者只需要set
     */
    @Test
    public void test02() {
        Map<String, String> map = new HashMap<String, String>();
        map.put("熊大", "棕色");
        map.put("熊二", "黄色");
        //key
        for (String key : map.keySet()) {
            System.out.println(key);
        }
        //value
        for (String value : map.values()) {
            System.out.println(value);
        }
    }

    /**
     * 通过Iterator遍历
     */
    @Test
    public void test03() {
        Map<String, String> map = new HashMap<String, String>();
        map.put("熊大", "棕色");
        map.put("熊二", "黄色");
        Iterator<Map.Entry<String, String>> entries = map.entrySet().iterator();
        while (entries.hasNext()) {
            Map.Entry<String, String> entry = entries.next();
            String key = entry.getKey();
            String value = entry.getValue();
            System.out.println(key + ":" + value);
        }
    }

    /**
     * 通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作
     */
    @Test
    public void test04() {
        Map<String, String> map = new HashMap<>();
        map.put("熊大", "棕色");
        map.put("熊二", "黄色");
        for(String key : map.keySet()){
            String value = map.get(key);
            System.out.println(key+":"+value);
        }
    }
}
```

#### 线程安全
1.HashMap是非同步的，没有对读写等操作进行锁保护，所以是线程不安全的，在多线程场景下会出现数据不一致的问题。而HashTable是同步的，所有的读写等操作都进行了锁（synchronized）保护，在多线程环境下没有安全问题。但是锁保护也是有代价的，会对读写的效率产生较大影响。  
2.HashMap的迭代器（Iterator）是fail-fast迭代器，但是Hashtable的迭代器（enumerator）不是fail-fast的。如果有其它线程对HashMap进行的添加/删除元素，将会抛出ConcurrentModificationException，但迭代器本身的remove方法移除元素则不会抛出异常。  

#### ConcurrentHashMap 类（是 Java并发包 java.util.concurrent 中提供的一个线程安全且高效的 HashMap 实现）
1. HashTable 是使用 synchronize 关键字加锁的原理（就是对对象加锁）,使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段就是一个小的hashtable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。 
2. HashMap 的键值对允许有null，但是ConCurrentHashMap 都不允许。
#### 扩容问题
HashMap的位桶数组一开始定义为16，实际使用时，当位桶数组中的元素达到0.75*length的时候，大小扩容为2倍；扩容很耗时，因为扩容的本质是拷贝
HashTable 为 11，扩容时扩大两倍+1； 
            
### TreeMap
用于排序的时候用到TreeMap,按照key自增的方式做了排序，排序规则如下：

 两个字符串 s1, s2比较

（1）、如果s1和s2是父子串关系，则 子串 < 父串

（2）、如果非为父子串关系， 则从第一个非相同字符来比较。

　　　  例子 s1 = "ab", s2 = "ac"    这种情况算法规则是从第二个字符开始比较，由于'b' < 'c' 所以  "ab" < "ac"

（3）、字符间的比较，是按照字符的字节码（ascii）来比较

2、  compareTo 实现机制：对于字符串来说，字典排序规则；对于数字来说，直接按照大小排序
>java.util.TreeMap.keySet() 返回Map中所有Entry（键值对）的集合。

## 4.Iterator
Iterable是一个超级接口，被Collection所继承。它只有一个方法： Iterator<T> iterator() //即返回一个迭代器  
如果要遍历的时候，删除某些元素，建议使用这种方式；
### fail-fast
快速失败(fail-fast) 是 Java 集合的一种错误检测机制。在使用迭代器对集合进行遍历的时候，我们在多线程下操作非安全失败(fail-safe)的集合类可能就会触发 fail-fast 机制，导致抛出 ConcurrentModificationException 异常。 另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。  
### 性能方面  
Collection的remove方法是有参的  必须首先找出要被删除的项，找到该项的位置采用的是单链表结构查询，单链表查询效率比较低，需要从集合中一个一个遍历才能找到该对象；  
collection的remove是每隔一行执行一次删除操作,意为着有的元素不会经过删除的操作.  
例如：一个ArrayList<String>，其包含的元素由["1","1","2"],如果删除1。用collection.remove进行移除,会发现第二个1依然存在.  
原因是：第一次遍历会把第0号元素"1"移除,于是第二个"1"成为了第0位元素.再执行第二遍遍历时,collection操作认为第0号元素的遍历已经完成,就直接对第1号元素进行遍历,此时第1号元素是"1.003",就造成了"0.002"没有被遍历到.  
Iterator的remove方法结合next()方法使用，比如集合中每隔一项删除一项，Iterator的remove()效率更高  
### 容错方面  
每当迭代器使用 hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedModCount 值，是的话就返回遍历；否则抛出异常，终止遍历。  
如果我们在集合被遍历期间对其进行修改的话，就会改变 modCount 的值，进而导致 modCount != expectedModCount ，进而抛出 ConcurrentModificationException 异常。  
通过 Iterator 的方法修改集合的话会修改到 expectedModCount 的值，所以不会抛出异常。  

```java
final void checkForComodification() {
    if (modCount != expectedModCount)
        throw new ConcurrentModificationException();
}

```
```java   
     Iterator iter = list.Iterator();            
     while(iter.hasNext()){
            Object obj = iter.next;
            iter.romove();
    }
    
```

###Collections工具类

#### 1.排序操作

Collections提供以下方法对List进行排序操作  
void reverse(List list)：反转  
void shuffle(List list),随机排序  
void sort(List list),按自然排序的升序排序  
void sort(List list, Comparator c);定制排序，由Comparator控制排序逻辑  
void swap(List list, int i , int j),交换两个索引位置的元素  
void rotate(List list, int distance),旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。  

#### 2.查找，替换操作

int binarySearch(List list, Object key), 对List进行二分查找，返回索引，注意List必须是有序的  
int max(Collection coll),根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)  
int max(Collection coll, Comparator c)，根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)  
void fill(List list, Object obj),用元素obj填充list中所有元素  
int frequency(Collection c, Object o)，统计元素出现次数  
int indexOfSubList(List list, List target), 统计targe在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).  
boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素。  

#### 3.同步控制

synchronizedCollection(Collection<T>  c) //返回指定 collection 支持的同步（线程安全的）collection。  
synchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。  
synchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。  
synchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。  


