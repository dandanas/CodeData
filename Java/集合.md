### 容器
 通俗一点讲，容器就是用来装其他对象的一种对象，数组就是一种容器  
Java 集合框架主要包括两种类型的容器，一种是Collection，存储一个元素集合，另一种是Map，存储键/值对映射。
Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、HashMap 
## 1.List
容器里面存的是对象的引用地址，调用`remove`方法的时候是在容器中移除的引用地址，而不是删除了对象`clear`同理
有序，可重复（e1 .equals(e2))
 
常用的实现类
### ArrayList
#### 特点
>查询效率高  

Array是用数组实现的，数组只需对 [基地址+元素大小*k] 就能找到第k+1个元素的地址，对其取地址就能获得该元素。
链表要获得第k个元素，这样就要从第一个元素找起，多了多步寻址操作，当数据量大且其它操作较少时，这就有差距了。
>增删效率低

因为数组是一个有序列表,数组是在连续的位置上面储存对象的应用。当删除某一个元素的时候在他后面的元素的索引都会左移，增加元素同理
链表可以将待删除的节点的前继节点next指针直接指向待删除元素的后续节点即可

>线程相关
##### 解决方案对比
> Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降关键源码如下：
```java
public class safe{
 public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }

public synchronized void removeElementAt(int index) {
        modCount++;
        if (index >= elementCount) {
            throw new ArrayIndexOutOfBoundsException(index + " >= " +
                                                     elementCount);
        }
        else if (index < 0) {
            throw new ArrayIndexOutOfBoundsException(index);
        }
        int j = elementCount - index - 1;
        if (j > 0) {
            System.arraycopy(elementData, index + 1, elementData, index, j);
        }
        elementCount--;
        elementData[elementCount] = null; /* to let gc do its work */
    }

 public synchronized Iterator<E> iterator() {
        return new Itr();
    }
}
```

> CopyOnWriteArrayList 

只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况.  
写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种优化策略。其核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。
>Collections.synchronizedList(List list) 

转换包装后的list可以实现add，remove，get等操作的线程安全性，但是对于迭代操作，Collections.synchronizedList并没有提供相关机制，所以迭代时需要对包装后的list（Must be manually synched by user）进行手动加锁

```java

synchronized (safeList) {
    while (iterator.hasNext()) {
        String next = iterator.next();
        System.out.println(next);
    }

```
synchronizedList实现线程安全的方法就是对自己暴力加锁，在获取安全的list后遍历时，外层要用synchronized同步是因为list.iterator()在读取过程中，不会本来hasNext()有的，但在调用i.next()的时候，另外一个线程把它删了，这个synchronized块是为了保障这三行代码在多个线程里同时执行的并发问题。
至于synchronizedList的内部锁，是在并发执行add/remove的时候，不要把多个线程的东西加到list内部实现的同一个位置上去，导致数据丢失或者脏数据等问题，这是为了保证这个List在执行add/remove时不会存在并发问题。                                                                   

### 线程不安全的解决方案 
```java
package testList;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.CopyOnWriteArrayList;

public class TestListSafe {
   // ArrayList    
   //会导致add内容为null,迭代时并发修改list内容抛ConcurrentModificationException异常
   // protected static ArrayList<Object> arrayList = new ArrayList<Object>();

    // 解决措施1：使用Vector集合
   // protected static Vector<Object> arrayListSafe1 = new Vector<Object>();

    // 解决措施2：加上Collections.synchronizedList，它会自动将我们的list方法进行改变，最后返回给我们一个加锁了List
    //static List<Object> arrayListSafe2 = Collections.synchronizedList(new ArrayList<Object>());
    //解决措施3：使用CopyOnWriteArrayList
    static List<Object>  arrayListSafe3 = new CopyOnWriteArrayList();


    public static void main(String[] args) {
        Thread[] threads = new Thread[500];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new ArrayListThread();
            threads[i].start();
        }

        for (int i = 0; i < threads.length; i++) {
            try {
                threads[i].join();// 等待该线程终止    
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 输出list中的对象元素    
        for (int i = 0; i < threads.length; i++) {
            System.out.println(arrayListSafe3.get(i));
        }
    }
}

/**
 * 线程类，执行arrayList的add()增加方法  
 *
 */
class ArrayListThread extends Thread {

    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 增加元素    
        TestListSafe.arrayListSafe3.add(Thread.currentThread().getName());
    }

}
```
### LinkedList：链表
LinkedList底层的数据结构是基于双向循环链表的，且头结点中不存放数据,查询效率低，增删效率高，线程不安全
```java
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
{}
```
LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。  
AbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些函数。  
LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。  
LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆（浅克隆）。  
LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。
#### 线程不安全的解决方案
>方法一:List<String> list = Collections.synchronizedList(new LinkedList<String>());

>方法二:将LinkedList全部换成ConcurrentLinkedQueue
#### Vector：线程安全的数组

## 2.Set
无序不可重复，没有索引，如果要查找只能去遍历，且只能放一个null元素

如何来保证元素唯一性? 依赖两个方法：hashCode()和equals()，HashSet是采用Hash算法实现的，底层实际上是用HashMap实现的，调用add方法的时候，如下，其实是存放的map的key，而key是不能重复的
```java
  public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }

```
### LinkedHashSet
继承自HashSet，唯一的区别是LinkedHashSet内部使用的是LinkHashMap。这样做的意义或者好处就是LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。  
底层数据结构是链表和哈希表。(FIFO插入有序,唯一)  
1.由链表保证元素有序  
2.由哈希表保证元素唯一
### TreeSet
底层实际上是TreeMap,同样按照递增的方式排列，数据结构是红黑树。(唯一，有序)  
1. 如何保证元素排序的呢?  
自然排序  
比较器排序  
2. 如何保证元素唯一性的呢?  
根据比较的返回值是否是0来决定  

## 4.Iterator
Iterable是一个超级接口，被Collection所继承。它只有一个方法： Iterator<T> iterator() //即返回一个迭代器  
如果要遍历的时候，删除某些元素，建议使用这种方式；
①性能方面  
Collection的remove方法是有参的  必须首先找出要被删除的项，找到该项的位置采用的是单链表结构查询，单链表查询效率比较低，需要从集合中一个一个遍历才能找到该对象；  
collection的remove是每隔一行执行一次删除操作,意为着有的元素不会经过删除的操作.  
例如：一个ArrayList<String>，其包含的元素由["1","1","2"],如果删除1。用collection.remove进行移除,会发现第二个1依然存在.  
原因是：第一次遍历会把第0号元素"1"移除,于是第二个"1"成为了第0位元素.再执行第二遍遍历时,collection操作认为第0号元素的遍历已经完成,就直接对第1号元素进行遍历,此时第1号元素是"1.003",就造成了"0.002"没有被遍历到.  
Iterator的remove方法结合next()方法使用，比如集合中每隔一项删除一项，Iterator的remove()效率更高  
②容错方面  
在使用Iterator遍历时，如果使用Collection的remove则会报异常，会出现ConcurrentModificationException，因为集合中对象的个数会改变而Iterator内部对象的个数不会，不一致则会出现该异常。  
在使用Iterator遍历时，不会报错，因为iterator内部的对象个数和原来集合中对象的个数会保持一致.
```java   
     Iterator iter = list.Iterator();            
     while(iter.hasNext()){
            Object obj = iter.next;
            iter.romove();
    }
    
```
## 3.Map
Hashtable:线程安全，不允许key和value为空，效率低  
HashMap ：线程不安全，允许key和value为空，效率高 ，结构是数组+链表，当链表长度超过 8 时，链表转换为红黑树。 
其中Node[] table 就是HashMap核心的数组结构，也称为"位桶数组",源码如下：

```java
 static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

       //以下代码省略
    }
```

#### 一个Node对象存储了：
1.key 键对象 value 值对象  
2.next 下一个节点  
3.hash 键对象的hash值  
所以Node对象是一个单向链表结构，然后把链表存储在一个数组里面

### HashMap存储键值对的过程
1.先调用key对象的hashCode方法，获得hashCode
 
2.根据hashCode计算hash值，要求在[0,数组长度-1]之间

3.存储之后生成一个链表， 根据hash值，将Node对象存储到数组索引位置
  jdk8中，当链表的长度大于8的时候链表就转化为红黑树，这样大大提高了转化效率  
#### HashMap取数据的过程
1.先调用key对象的hashCode方法，获得hashCode  
2.根据hashCode计算hash值，要求在[0,数组长度-1]之间  
3.通过equals方法依次 比较，然后将对应的value对象返回回去  

Java中规定，两个内容相同equals为true的对象必须有相同的hashCode,如果不同，则发生了悖论

#### 线程安全
1.HashMap是非同步的，没有对读写等操作进行锁保护，所以是线程不安全的，在多线程场景下会出现数据不一致的问题。而HashTable是同步的，所有的读写等操作都进行了锁（synchronized）保护，在多线程环境下没有安全问题。但是锁保护也是有代价的，会对读写的效率产生较大影响。  
2.HashMap的迭代器（Iterator）是fail-fast迭代器，但是Hashtable的迭代器（enumerator）不是fail-fast的。如果有其它线程对HashMap进行的添加/删除元素，将会抛出ConcurrentModificationException，但迭代器本身的remove方法移除元素则不会抛出异常。  

#### ConcurrentHashMap 类（是 Java并发包 java.util.concurrent 中提供的一个线程安全且高效的 HashMap 实现）
1. HashTable 是使用 synchronize 关键字加锁的原理（就是对对象加锁）,使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；ConcurrentHashMap采用了CAS（无锁算法）+ synchronized,所以ConcurrentHashMap效率高
2. HashMap 的键值对允许有null，但是ConCurrentHashMap 都不允许。
#### 扩容问题
HashMap的位桶数组一开始定义为16，实际使用时，当位桶数组中的元素达到0.75*length的时候，大小扩容为2倍；扩容很耗时，因为扩容的本质是拷贝
HashTable 为 11，扩容时扩大两倍+1； 
            
### TreeMap
用于排序的时候用到TreeMap,按照key自增的方式做了排序，排序规则如下：

 两个字符串 s1, s2比较

（1）、如果s1和s2是父子串关系，则 子串 < 父串

（2）、如果非为父子串关系， 则从第一个非相同字符来比较。

　　　  例子 s1 = "ab", s2 = "ac"    这种情况算法规则是从第二个字符开始比较，由于'b' < 'c' 所以  "ab" < "ac"

（3）、字符间的比较，是按照字符的字节码（ascii）来比较

2、  compareTo 实现机制：对于字符串来说，字典排序规则；对于数字来说，直接按照大小排序
>java.util.TreeMap.keySet() 返回Map中所有Entry（键值对）的集合。


###Collections工具类


