### 容器
 通俗一点讲，容器就是用来装其他对象的一种对象，数组就是一种容器，集合 
#### 容器有哪些
常用的java容器有三大类：顺序存储的list，去重的set，存储键值对的map
## 1.List
容器里面存的是对象的引用地址，调用`remove`方法的时候是在容器中移除的引用地址，而不是删除了对象`clear`同理
有序，可重复（e1 .equals(e2))
 
常用的实现类
#### ArrayList
底层实现用数组
>查询效率高 

Array是用数组实现的，数组只需对 [基地址+元素大小*k] 就能找到第k+1个元素的地址，对其取地址就能获得该元素。链表要获得第k个元素，首先要在其第k-1个元素寻找到其next指针偏移，再将next指针作为地址获得值，这样就要从第一个元素找起，多了多步寻址操作，当数据量大且其它操作较少时，这就有差距了。
>增删效率低
>
因为数组是一个有序列表 ，数组是在连续的位置上面储存对象的应用。当我们删除某一个元素的时候在他后面的元素的索引都会左移，增加元素同理，而链表可以将待删除的节点的前继节点next指针直接指向待删除元素的后续节点即可
##### 数组的长度是有限的，但是ArrayList是可以存放任意数量的长度不受限制，其实现方法是：
  可以定义长度，如果长度不传，默认是10，扩容方法：原长度+原长度的二分之一 
#### ArrayList线程相关
##### 线程安全
多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。
##### 线程不安全
就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。
##### 解决方案对比
> Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降关键源码如下：
```java
 public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }

public synchronized void removeElementAt(int index) {
        modCount++;
        if (index >= elementCount) {
            throw new ArrayIndexOutOfBoundsException(index + " >= " +
                                                     elementCount);
        }
        else if (index < 0) {
            throw new ArrayIndexOutOfBoundsException(index);
        }
        int j = elementCount - index - 1;
        if (j > 0) {
            System.arraycopy(elementData, index + 1, elementData, index, j);
        }
        elementCount--;
        elementData[elementCount] = null; /* to let gc do its work */
    }

 public synchronized Iterator<E> iterator() {
        return new Itr();
    }
```
>
> CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况。

写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种优化策略。其核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。
>Collections.synchronizedList(List list) 返回的是一个 SynchronizedList 的对象，这个对象以组合的方式将对 List 的接口方法操作，委托给传入的 list 对象，并且对所有的接口方法对象加锁，得到并发安全性。
>
>转换包装后的list可以实现add，remove，get等操作的线程安全性，但是对于迭代操作，Collections.synchronizedList并没有提供相关机制，所以迭代时需要对包装后的list（Must be manually synched by user）进行手动加锁
>
```java

synchronized (safeList) {
    while (iterator.hasNext()) {
        String next = iterator.next();
        System.out.println(next);
    }

```
>synchronizedList实现线程安全的方法就是对自己暴力加锁，在获取安全的list后遍历时，外层要用synchronized同步是因为list.iterator()在读取过程中，不会本来hasNext()有的，但在调用i.next()的时候，另外一个线程把它删了，这个synchronized块是为了保障这三行代码在多个线程里同时执行的并发问题。
>至于synchronizedList的内部锁，是在并发执行add/remove的时候，不要把多个线程的东西加到list内部实现的同一个位置上去，导致数据丢失或者脏数据等问题，这是为了保证这个List在执行add/remove时不会存在并发问题。                                                                   

####线程不安全的解决方案 
```java
package testList;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.CopyOnWriteArrayList;

public class TestListSafe {
   // ArrayList    
   //会导致add内容为null,迭代时并发修改list内容抛ConcurrentModificationException异常
   // protected static ArrayList<Object> arrayList = new ArrayList<Object>();

    // 解决措施1：使用Vector集合
   // protected static Vector<Object> arrayListSafe1 = new Vector<Object>();

    // 解决措施2：加上Collections.synchronizedList，它会自动将我们的list方法进行改变，最后返回给我们一个加锁了List
    //static List<Object> arrayListSafe2 = Collections.synchronizedList(new ArrayList<Object>());
    //解决措施3：使用CopyOnWriteArrayList
    static List<Object>  arrayListSafe3 = new CopyOnWriteArrayList();


    public static void main(String[] args) {
        Thread[] threads = new Thread[500];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new ArrayListThread();
            threads[i].start();
        }

        for (int i = 0; i < threads.length; i++) {
            try {
                threads[i].join();// 等待该线程终止    
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 输出list中的对象元素    
        for (int i = 0; i < threads.length; i++) {
            System.out.println(arrayListSafe3.get(i));
        }
    }
}

/**
 * 线程类，执行arrayList的add()增加方法  
 *
 */
class ArrayListThread extends Thread {

    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 增加元素    
        TestListSafe.arrayListSafe3.add(Thread.currentThread().getName());
    }

}
```
###LinkedList：链表
查询效率低，增删效率高，线程不安全
```java
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
{}
```
>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。
>
AbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些骨干性函数。降低了List接口的复杂度。这些接口都是随机访问List的，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了“get(int index)这些接口”。
>
 LinkedList 实现 List 接口，能对它进行队列操作。
 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。
 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。
 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。
 LinkedList 是线程不安全的
#####线程不安全的解决方案
>方法一:List<String> list = Collections.synchronizedList(new LinkedList<String>());
>方法二:将LinkedList全部换成ConcurrentLinkedQueue
####Vector：线程安全的数组
##2.Map
####Hashtable:线程安全，不允许key和value为空，效率低
####HashMap ：线程不安全，允许key和value为空，效率高
其中Node[] table 就是HashMap核心的数组结构，也称为"位桶数组",源码如下：

```java
 static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

       //以下代码省略
    }
```

####一个Node对象存储了：
>1.key 键对象 value 值对象
>
>2.next 下一个节点
>
>3.hash 键对象的hash值
>
>所以Node对象是一个单向链表结构，然后把链表存储在一个数组里面
>
####HashMap存储键值对的过程
1.先调用key对象的hashCode方法，获得hashCode
 
2.根据hashCode计算hash值，要求在[0,数组长度-1]之间

3.存储之后生成一个链表， 根据hash值，将Node对象存储到数组索引位置
>jdk8中，当链表的长度大于8的时候链表就转化为红黑树，这样大大提高了转化效率
>
####HashMap取数据的过程
1.先调用key对象的hashCode方法，获得hashCode
 
2.根据hashCode计算hash值，要求在[0,数组长度-1]之间

3.通过equals方法依次 比较，然后将对应的value对象返回回去 

Java中规定，两个内容相同equals为true的对象必须有相同的hashCode,如果不同，则发生了悖论

####扩容问题
HashMap的位桶数组一开始定义为16，实际使用时，当位桶数组中的元素达到0.75*length的时候，大小扩容为2倍；扩容很耗时，因为扩容的本质是拷贝

我所理解的哈希是指一个过程，这个过程就是把任意长度的输入，通过哈希算法，变换成固定长度的输出，所输出的称为哈希值。这种变换是一种压缩映射，也即哈希值所占的空间一般来说远小于输入值的空间，不同的输入可能会哈希出相同的输出（概率很小）。
                  
###TreeMap
用于排序的时候用到TreeMap,按照key自增的方式做了排序，排序规则如下：

 两个字符串 s1, s2比较

（1）、如果s1和s2是父子串关系，则 子串 < 父串

（2）、如果非为父子串关系， 则从第一个非相同字符来比较。

　　　  例子 s1 = "ab", s2 = "ac"    这种情况算法规则是从第二个字符开始比较，由于'b' < 'c' 所以  "ab" < "ac"

（3）、字符间的比较，是按照字符的字节码（ascii）来比较

2、  compareTo 实现机制：对于字符串来说，字典排序规则；对于数字来说，直接按照大小排序
>java.util.TreeMap.keySet() 返回Map中所有Entry（键值对）的集合。
>

##3.Set
无序不可重复🙅，没有索引，如果要查找只能去遍历，且只能放一个null元素

HashSet是采用Hash算法实现的，底层实际上是用HashMap实现的，调用add方法的时候，如下，其实是存放的map的key，而key是不能重复的
```java
  public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }

```

TreeSet底层实际上是TreeMap,同样按照递增的方式排列

##4.Iterator
Iterable是一个超级接口，被Collection所继承。它只有一个方法： Iterator<T> iterator() //即返回一个迭代器

如果要遍历的时候，删除某些元素，建议使用这种方式
```java   
     Iterator iter = list.Iterator();            
     while(iter.hasNext()){
            Object obj = iter.next;
            iter.romove();
    }
    
```

###Collection工具类


