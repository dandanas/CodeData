####容器
 通俗一点讲，容器就是用来装其他对象的一种对象，数组就是一种容器，集合
####数组的优势
数组是一种简单的线性序列，可以快速的访问数组的元素，效率高
####数组的劣势
不灵活，容量要事先定义好，不能随着需求变化而扩容

##List
容器里面存的是对象的引用地址，调用`remove`方法的时候是在容器中移除的引用地址，而不是删除了对象
`clear`同理

>有序，可重复（e1 .equals(e2))
 
常用的实现类
>ArrayList： 底层实现用数组，查询效率高，增删效率低，线程不安全 
>
###数组的长度是有限的，但是ArrayList是可以存放任意数量的长度不受限制，其实现方法是：
 可以定义长度，如果长度不传，默认是10
 remove操作源码实现是 通过拷贝  删除某个元素是通过移动后面的元素实现 ，所以增删效率低
 扩容：原长度+原长度的二分之一 //why
>LinkedList：链表
>
>查询效率低，增删效率高，线程不安全
>
>Vector：线程安全的数组
>
>HashMap ：线程不安全，允许key和value为空，效率高
>
>Hashtable:线程安全，不允许key和value为空，效率低
  
其中Node[] table 就是HashMap核心的数组结构，也称为"位桶数组",源码如下：

```java
 static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

       //一下午代码省略
    }
```

一个Node对象存储了：
>1.key 键对象 value 值对象
>
>2.next 下一个节点
>
>3.hash 键对象的hash值
>
>所以Node对象是一个单向链表结构，然后把链表存储在一个数组里面
>
####HashMap存储键值对的过程
1.先调用key对象的hashCode方法，获得hashCode
 
2.根据hashCode计算hash值，要求在[0,数组长度-1]之间

3.存储之后生成一个链表， 根据hash值，将Node对象存储到数组索引位置
>jdk8中，当链表的长度大于8的时候链表就转化为红黑树，这样大大提高了转化效率
>
####HashMap取数据的过程
1.先调用key对象的hashCode方法，获得hashCode
 
2.根据hashCode计算hash值，要求在[0,数组长度-1]之间

3.通过equals方法依次 比较，然后将对应的value对象返回回去 

Java中规定，两个内容相同equals为true的对象必须有相同的hashCode,如果不同，则发生了悖论

####扩容问题
HashMap的位桶数组一开始定义为16，实际使用时，当位桶数组中的元素达到0.75*length的时候，大小扩容为2倍；扩容很耗时，因为扩容的本质是拷贝

我所理解的哈希是指一个过程，这个过程就是把任意长度的输入，通过哈希算法，变换成固定长度的输出，所输出的称为哈希值。这种变换是一种压缩映射，也即哈希值所占的空间一般来说远小于输入值的空间，不同的输入可能会哈希出相同的输出（概率很小）。
                  
###TreeMap
用于排序的时候用到TreeMap,按照key自增的方式做了排序，排序规则如下：

 两个字符串 s1, s2比较

（1）、如果s1和s2是父子串关系，则 子串 < 父串

（2）、如果非为父子串关系， 则从第一个非相同字符来比较。

　　　  例子 s1 = "ab", s2 = "ac"    这种情况算法规则是从第二个字符开始比较，由于'b' < 'c' 所以  "ab" < "ac"

（3）、字符间的比较，是按照字符的字节码（ascii）来比较

2、  compareTo 实现机制：对于字符串来说，字典排序规则；对于数字来说，直接按照大小排序
>java.util.TreeMap.keySet() 返回Map中所有Entry（键值对）的集合。
>

##Set
无序不可重复🙅，没有索引，如果要查找只能去遍历，且只能放一个null元素

HashSet是采用Hash算法实现的，底层实际上是用HashMap实现的，调用add方法的时候，如下，其实是存放的map的key，而key是不能重复的
```java
  public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }

```

TreeSet底层实际上是TreeMap,同样按照递增的方式排列

###Iterator
如果要遍历的时候，删除某些元素，建议使用这种方式
```java
     Iterator iter = list.Iterator();            
     while(iter.hasNext()){
            Object obj = iter.next;
            iter.romove();
    }
    
```

###Collection工具类


