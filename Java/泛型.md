###泛型
泛型的本质就是数据类型参数化，可以理解为数据类型的占位符（形式参数），即告诉编译器，在调用泛型时必须 传入实际类型


>1.泛型是实例化的时候指定的而静态结构早于对象的创建，所以在静态方法中是不能使用泛型的
>
>2.异常类不能声明为泛型 因为被指定的泛型可能不一定是异常类型
>
>3.不能使用E[] 
```java
public class test() {
        public Order() {
            //编译不通过
            //T[] arr = new T[10]
            T[] arr = new Object[(10)];
        }
    }
```
>4.父类有泛型，子类可以保留泛型也可以不保留
```java
class Father<T1,T2>{
        
    }
    //子类不保留父类的泛型
    //1.没有类型，擦除
    class Son1 extends Father{
        //等价于class Son1 extends Father<Object,Object>
    }
    //2.具体类型
    class Son2 extends Father<String ,Integer>{
        
    }
    //子类保留父类的泛型
    //1.全部保留
    class Son3 extends Father<T1,T2>{
        
    }
    //2.部分保留
    class Son4 extends Father<Integer,T2>{

    }
    
```

>5.泛型方法,在方法中出现了方法结构,泛型参数与类的泛型参数没有任何关系
>
```java
    public <E> List<E>  test04(E[] arr) {
        ArrayList<E> list = new ArrayList<>();
        for (E e:arr){
            list.add(e);
        }
        return list;
        
    }
```
>6.泛型方法是在调用时，指明泛型参数的类型，因此泛型方法可以是static的
>
>7.类A是类B的父类，G<A>和G<B> 不是子父类关系,二者公共的父类是G<?>
>
```java
        List<Object> list1 = new ArrayList<>();
        List<String> list2 = new ArrayList<>();
        
        list1.add(123);
        //list1 = list2;导致混入非String的数据
```
>8.通配符的使用 ？,对于List<?>不能向其内部添加数据，除了添加null，允许读取数据，读取数据额类型为
Object
```java
        List<Object> list1 = null;
        List<String> list2 = null;
        List<?> list = null;
        list = list1;
        list = list2;
```
>9.有限制条件的通配符：
```java
? extends A:
    G<? extends A> 可以作为G<A>和G<B>的父类，其中B是A的子类
? super A:
    G<? super A> 可以作为G<A>和G<B>的父类，其中B是A的父类
```